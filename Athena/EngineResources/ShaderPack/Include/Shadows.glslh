//////////////////////// Athena Shadows ////////////////////////

// References:
// https://github.com/TheMasonX/UnityPCSS/blob/master/Assets/PCSS/Shaders/PCSS.shader
// https://http.download.nvidia.com/developer/presentations/2005/SIGGRAPH/Percentage_Closer_Soft_Shadows.pdf


#define DEBUG_BLEND_CASCADES
//#define USE_BIAS

#define SHADOWS_PRESET 2

/*--------------------------------------------------------------------------*/
#if (SHADOWS_PRESET == 0)
	#define BLOCKER_SEARCH_SAMPLES 16
	#define PCF_SEARCH_SAMPLES	   16
	#define BLEND_CASCADES		   0
	#define POISSON_16
#endif
/*--------------------------------------------------------------------------*/
#if (SHADOWS_PRESET == 1)
	#define BLOCKER_SEARCH_SAMPLES 16
	#define PCF_SEARCH_SAMPLES	   16
	#define BLEND_CASCADES		   1
	#define POISSON_16
#endif
/*--------------------------------------------------------------------------*/
#if (SHADOWS_PRESET == 2)
	#define BLOCKER_SEARCH_SAMPLES 32
	#define PCF_SEARCH_SAMPLES	   32
	#define BLEND_CASCADES		   1
	#define POISSON_32
#endif
/*--------------------------------------------------------------------------*/
#if (SHADOWS_PRESET == 3)
	#define BLOCKER_SEARCH_SAMPLES 64
	#define PCF_SEARCH_SAMPLES	   64
	#define BLEND_CASCADES		   1
	#define POISSON_64
#endif
#if (SHADOWS_PRESET == 4)
	#define BLOCKER_SEARCH_SAMPLES 64
	#define PCF_SEARCH_SAMPLES	   64
	#define BLEND_CASCADES		   1
	#define POISSON_64
	#define ROTATE_SAMPLE
#endif
/*--------------------------------------------------------------------------*/

#if defined(POISSON_16)
const vec2 PoissonDisk[16] = vec2[](
    vec2( -0.9420162,  -0.39906216 ),
    vec2( 0.94558609,  -0.76890725 ),
    vec2( -0.0941841,  -0.92938870 ),
    vec2( 0.34495938,   0.29387760 ),
    vec2( -0.91588581,  0.45771432 ),
    vec2( -0.81544232, -0.87912464 ),
    vec2( -0.38277543,  0.27676845 ),
    vec2( 0.97484398,   0.75648379 ),
    vec2( 0.44323325,  -0.97511554 ),
    vec2( 0.53742981,  -0.47373420 ),
    vec2( -0.26496911, -0.41893023 ),
    vec2( 0.79197514,   0.19090188 ),
    vec2( -0.24188840,  0.99706507 ),
    vec2( -0.81409955,  0.91437590 ),
    vec2( 0.19984126,   0.78641367 ),
    vec2( 0.14383161,  -0.14100790 ));
#elif defined(POISSON_32)
const vec2 PoissonDisk[32] = {
	vec2(0.06407013, 0.05409927),
	vec2(0.7366577, 0.5789394),
	vec2(-0.6270542, -0.5320278),
	vec2(-0.4096107, 0.8411095),
	vec2(0.6849564, -0.4990818),
	vec2(-0.874181, -0.04579735),
	vec2(0.9989998, 0.0009880066),
	vec2(-0.004920578, -0.9151649),
	vec2(0.1805763, 0.9747483),
	vec2(-0.2138451, 0.2635818),
	vec2(0.109845, 0.3884785),
	vec2(0.06876755, -0.3581074),
	vec2(0.374073, -0.7661266),
	vec2(0.3079132, -0.1216763),
	vec2(-0.3794335, -0.8271583),
	vec2(-0.203878, -0.07715034),
	vec2(0.5912697, 0.1469799),
	vec2(-0.88069, 0.3031784),
	vec2(0.5040108, 0.8283722),
	vec2(-0.5844124, 0.5494877),
	vec2(0.6017799, -0.1726654),
	vec2(-0.5554981, 0.1559997),
	vec2(-0.3016369, -0.3900928),
	vec2(-0.5550632, -0.1723762),
	vec2(0.925029, 0.2995041),
	vec2(-0.2473137, 0.5538505),
	vec2(0.9183037, -0.2862392),
	vec2(0.2469421, 0.6718712),
	vec2(0.3916397, -0.4328209),
	vec2(-0.03576927, -0.6220032),
	vec2(-0.04661255, 0.7995201),
	vec2(0.4402924, 0.3640312),
};
#elif defined(POISSON_64)
const vec2 PoissonDisk[64] = {
	vec2(0.0617981, 0.07294159),
	vec2(0.6470215, 0.7474022),
	vec2(-0.5987766, -0.7512833),
	vec2(-0.693034, 0.6913887),
	vec2(0.6987045, -0.6843052),
	vec2(-0.9402866, 0.04474335),
	vec2(0.8934509, 0.07369385),
	vec2(0.1592735, -0.9686295),
	vec2(-0.05664673, 0.995282),
	vec2(-0.1203411, -0.1301079),
	vec2(0.1741608, -0.1682285),
	vec2(-0.09369049, 0.3196758),
	vec2(0.185363, 0.3213367),
	vec2(-0.1493771, -0.3147511),
	vec2(0.4452095, 0.2580113),
	vec2(-0.1080467, -0.5329178),
	vec2(0.1604507, 0.5460774),
	vec2(-0.4037193, -0.2611179),
	vec2(0.5947998, -0.2146744),
	vec2(0.3276062, 0.9244621),
	vec2(-0.6518704, -0.2503952),
	vec2(-0.3580975, 0.2806469),
	vec2(0.8587891, 0.4838005),
	vec2(-0.1596546, -0.8791054),
	vec2(-0.3096867, 0.5588146),
	vec2(-0.5128918, 0.1448544),
	vec2(0.8581337, -0.424046),
	vec2(0.1562584, -0.5610626),
	vec2(-0.7647934, 0.2709858),
	vec2(-0.3090832, 0.9020988),
	vec2(0.3935608, 0.4609676),
	vec2(0.3929337, -0.5010948),
	vec2(-0.8682281, -0.1990303),
	vec2(-0.01973724, 0.6478714),
	vec2(-0.3897587, -0.4665619),
	vec2(-0.7416366, -0.4377831),
	vec2(-0.5523247, 0.4272514),
	vec2(-0.5325066, 0.8410385),
	vec2(0.3085465, -0.7842533),
	vec2(0.8400612, -0.200119),
	vec2(0.6632416, 0.3067062),
	vec2(-0.4462856, -0.04265022),
	vec2(0.06892014, 0.812484),
	vec2(0.5149567, -0.7502338),
	vec2(0.6464897, -0.4666451),
	vec2(-0.159861, 0.1038342),
	vec2(0.6455986, 0.04419327),
	vec2(-0.7445076, 0.5035095),
	vec2(0.9430245, 0.3139912),
	vec2(0.0349884, -0.7968109),
	vec2(-0.9517487, 0.2963554),
	vec2(-0.7304786, -0.01006928),
	vec2(-0.5862702, -0.5531025),
	vec2(0.3029106, 0.09497032),
	vec2(0.09025345, -0.3503742),
	vec2(0.4356628, -0.0710125),
	vec2(0.4112572, 0.7500054),
	vec2(0.3401214, -0.3047142),
	vec2(-0.2192158, -0.6911137),
	vec2(-0.4676369, 0.6570358),
	vec2(0.6295372, 0.5629555),
	vec2(0.1253822, 0.9892166),
	vec2(-0.1154335, 0.8248222),
	vec2(-0.4230408, -0.7129914),
};
#endif

layout(std140, set = 1, binding = 5) uniform u_ShadowsData
{
	mat4 u_DirLightViewProjection[SHADOW_CASCADES_COUNT];
	vec4 u_CascadePlanes[SHADOW_CASCADES_COUNT];	// stores only x and y (near and far)
	float u_ShadowMaxDistance;
	float u_MaxDistanceFadeOut;
    float u_CascadeBlendDistance;
	int u_SoftShadows;
};

layout(set = 1, binding = 6) uniform sampler2DArray u_DirShadowMap;
layout(set = 1, binding = 7) uniform sampler2DArrayShadow u_DirShadowMapShadow;
layout(set = 1, binding = 8) uniform sampler2D u_PCSSNoise;

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++    Helper Methods    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float SampleShadowMapDepth(vec2 uv, int cascade)
{
    return texture(u_DirShadowMap, vec3(uv, cascade)).r;
}

float SampleShadowMapCompare(vec3 shadowCoords, int cascade)
{
    return texture(u_DirShadowMapShadow, vec4(shadowCoords.xy, cascade, shadowCoords.z));
}

vec3 GetShadowCoords(vec3 worldPos, int cascade)
{
	 vec4 lightSpacePosition = u_DirLightViewProjection[cascade] * vec4(worldPos, 1.0);
     vec2 uv = 0.5 * lightSpacePosition.xy / lightSpacePosition.w + 0.5;
     return vec3(uv, lightSpacePosition.z);
}

float GetBias(vec3 normal, vec3 lightDir, int cascade)
{
    return max(0.00001 * (1.0 - dot(normal, lightDir)), 0.00001);
}

vec2 Rotate(vec2 pos, vec2 rotationTrig)
{
	return vec2(pos.x * rotationTrig.x - pos.y * rotationTrig.y, pos.y * rotationTrig.x + pos.x * rotationTrig.y);
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   Cascades    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

int GetShadowCascade(float depthViewSpace)
{
    int cascade = SHADOW_CASCADES_COUNT;
    for(int i = 0; i < SHADOW_CASCADES_COUNT; ++i)
    {
        if(depthViewSpace < u_CascadePlanes[i].y)
        {
            cascade = i;
            break;
        }
    }

    return cascade;
}

float GetShadowMaxDistanceFade(float distanceFromCamera)
{
    float maxDistance = u_ShadowMaxDistance;
    float fadeOut = u_MaxDistanceFadeOut;

    return clamp(smoothstep(0.0, 1.0, (distanceFromCamera - (maxDistance - fadeOut)) / fadeOut), 0.0, 1.0);
}

float GetCascadeScale(int cascade)
{
    float scale = 1.0;
    switch(cascade)
    {
    case 0: scale = 1.0; break;
    case 1: scale = 2.0; break;
    case 2: scale = 3.0; break;
    case 3: scale = 4.0; break;
    }
    
   return 1.0 / scale;
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   PCSS    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float PenumbraSize(float zReceiver, float zBlocker)
{
    return (zReceiver - zBlocker) / zBlocker;
}

vec2 FindBlocker(vec2 uv, float depth, int cascade, float searchSize, float scale, vec2 rotationTrig)
{
	float numBlockers = 0.0;
	float blockerSum = 0.0;

	for(int i = 0; i < BLOCKER_SEARCH_SAMPLES; ++i)
	{
		vec2 offset = PoissonDisk[i] * searchSize * scale;

#if defined(ROTATE_SAMPLE)
		offset = Rotate(offset, rotationTrig);
#endif

		float shadowMapDepth = SampleShadowMapDepth(uv + offset, cascade);

		if(shadowMapDepth < depth)
		{
			blockerSum += shadowMapDepth;
			numBlockers += 1.0;
		}
	}

	float avgBlockerDepth = blockerSum / numBlockers;

	return vec2(avgBlockerDepth, numBlockers);
}

float PCF_Filter(vec2 uv, float depth, int cascade, float filterRadiusUV, float scale, vec2 rotationTrig)
{
	float sum = 0.0;

	for(int i = 0; i < PCF_SEARCH_SAMPLES; ++i)
	{
		vec2 offset = PoissonDisk[i] * filterRadiusUV * scale;

#if defined(ROTATE_SAMPLE)
		offset = Rotate(offset, rotationTrig);
#endif

		float value = SampleShadowMapCompare(vec3(uv + offset, depth), cascade);
		sum += value;
	}

	sum /= PCF_SEARCH_SAMPLES;
	return sum;
}

float ShadowPCSS(vec3 shadowCoords, int cascade, float lightSize, vec2 noiseUV)
{
    vec2 uv = shadowCoords.xy;
    float depth = shadowCoords.z;
    float scale = GetCascadeScale(cascade);

	float random = texture(u_PCSSNoise, noiseUV / textureSize(u_PCSSNoise, 0).xy).r;
	random = 2.0 * random - 1.0;

	float rotationAngle = random * 3.1415926;
	vec2 rotationTrig = vec2(cos(rotationAngle), sin(rotationAngle));
	//rotationTrig = vec2(0, 1);

    // STEP 1: blocker search
    float searchSize = lightSize * clamp(depth - 0.02, 0.0, 1.0) / depth;
    vec2 blockerInfo = FindBlocker(uv, depth, cascade, searchSize, scale, rotationTrig);

    int numBlockers = int(blockerInfo.y);
    float avgBlockerDepth = blockerInfo.x;

    // There are no occluders so early out
    if(numBlockers == 0)
        return 1.0;

	// Do not perform filtering if full shadowed
	if(numBlockers == BLOCKER_SEARCH_SAMPLES)
		return 0.0;

    // STEP 2: penumbra size
    //float penumbra = depth * depth - avgBlockerDepth * avgBlockerDepth;
	float penumbra = depth - avgBlockerDepth;

	//float filterRadiusUV = penumbra * lightSize;
    float filterRadiusUV = clamp(penumbra * lightSize, 0.001, 0.1);

    return PCF_Filter(uv, depth, cascade, filterRadiusUV, scale, rotationTrig);
}


/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   MAIN    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float ShadowHard(vec3 shadowCoords, int cascade)
{
    return SampleShadowMapCompare(shadowCoords, cascade);
}

float Shadow(vec3 shadowCoords, int cascade, float lightSize, vec2 noiseUV)
{
	if(bool(u_SoftShadows))
	{
		return 1.0 - ShadowPCSS(shadowCoords, cascade, lightSize, noiseUV);
	}
	
	return 1.0 - ShadowHard(shadowCoords, cascade);
}

float ComputeDirectionalLightShadow(float lightSize, vec3 lightDir, vec3 normal, vec3 worldPos, float distanceFromCamera, mat4 cameraView, vec2 noiseUV)
{
    float fadeOut = GetShadowMaxDistanceFade(distanceFromCamera);
    if(fadeOut >= 1.0)
        return 0.0;

    vec4 wposViewSpace = cameraView * vec4(worldPos, 1.0);
    float depthViewSpace = abs(wposViewSpace.z);

    int cascade = GetShadowCascade(depthViewSpace);
    vec3 shadowCoords = GetShadowCoords(worldPos, cascade);

#if defined(USE_BIAS)
	float bias = GetBias(normal, lightDir, cascade);
	shadowCoords.z += bias;
#endif

    if(shadowCoords.z > 1.0) 
		return 0.0;

	float shadow = Shadow(shadowCoords, cascade, lightSize, noiseUV);

#if BLEND_CASCADES == 1

    float near = u_CascadePlanes[cascade].x;
    float far = u_CascadePlanes[cascade].y;

    float alpha = (depthViewSpace - near) / (far - near);

    if(u_CascadeBlendDistance != 0.0 && alpha > 1.0 - u_CascadeBlendDistance && cascade != SHADOW_CASCADES_COUNT - 1)
    {
        // get alpha to 0..1 range over the blend distance
        alpha = (alpha - (1.0 - u_CascadeBlendDistance)) / u_CascadeBlendDistance;

        int nextCascade = cascade + 1;
        shadowCoords = GetShadowCoords(worldPos, nextCascade);

        float shadowNextCascade = Shadow(shadowCoords, nextCascade, lightSize, noiseUV);

        shadow = mix(shadow, shadowNextCascade, clamp(alpha, 0.0, 1.0));
    }

#endif

    return (1.0 - fadeOut) * shadow;
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++    Debug    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

vec3 GetCascadeDebugColor(vec3 worldPos, mat4 cameraView)
{
    vec4 wposViewSpace = cameraView * vec4(worldPos, 1.0);
    float depthViewSpace = abs(wposViewSpace.z);

    int cascade = GetShadowCascade(depthViewSpace);

    const vec3 debugColors[4] = vec3[](
        vec3(1.0, 0.0, 0.0), 
        vec3(0.0, 1.0, 0.0), 
        vec3(0.0, 0.0, 1.0), 
        vec3(1.0, 1.0, 0.0));

    vec3 color = debugColors[cascade];

#if defined(DEBUG_BLEND_CASCADES) && BLEND_CASCADES == 1

    float near = u_CascadePlanes[cascade].x;
    float far = u_CascadePlanes[cascade].y;

    float alpha = (depthViewSpace - near) / (far - near);

    if(alpha > 1.0 - u_CascadeBlendDistance && cascade != SHADOW_CASCADES_COUNT - 1)
    {
        // get alpha to 0..1 range over the blend distance
        alpha = (alpha - (1.0 - u_CascadeBlendDistance)) / u_CascadeBlendDistance;

        vec3 colorNextCascade = debugColors[cascade + 1];

        color = mix(color, colorNextCascade, clamp(alpha, 0.0, 1.0));
    }

#endif

   return color;
}
