//////////////////////// Athena Shadows ////////////////////////

// References:
// https://github.com/TheMasonX/UnityPCSS/blob/master/Assets/PCSS/Shaders/PCSS.shader
// https://http.download.nvidia.com/developer/presentations/2005/SIGGRAPH/Percentage_Closer_Soft_Shadows.pdf


#define DEBUG_BLEND_CASCADES
#define SHADOWS_PRESET 3

/*--------------------------------------------------------------------------*/
#if (SHADOWS_PRESET == 0)
	#define BLOCKER_SEARCH_SAMPLES 16
	#define PCF_SEARCH_SAMPLES	   16
	#define BLEND_CASCADES		   0
#endif
/*--------------------------------------------------------------------------*/
#if (SHADOWS_PRESET == 1)
	#define BLOCKER_SEARCH_SAMPLES 32
	#define PCF_SEARCH_SAMPLES	   32
	#define BLEND_CASCADES		   0
#endif
/*--------------------------------------------------------------------------*/
#if (SHADOWS_PRESET == 2)
	#define BLOCKER_SEARCH_SAMPLES 32
	#define PCF_SEARCH_SAMPLES	   32
	#define BLEND_CASCADES		   1
#endif
/*--------------------------------------------------------------------------*/
#if (SHADOWS_PRESET == 3)
	#define BLOCKER_SEARCH_SAMPLES 32
	#define PCF_SEARCH_SAMPLES	   64
	#define BLEND_CASCADES		   1
#endif
/*--------------------------------------------------------------------------*/


const vec2 PoissonDisk[64] = {
	vec2(0.0617981, 0.07294159),
	vec2(0.6470215, 0.7474022),
	vec2(-0.5987766, -0.7512833),
	vec2(-0.693034, 0.6913887),
	vec2(0.6987045, -0.6843052),
	vec2(-0.9402866, 0.04474335),
	vec2(0.8934509, 0.07369385),
	vec2(0.1592735, -0.9686295),
	vec2(-0.05664673, 0.995282),
	vec2(-0.1203411, -0.1301079),
	vec2(0.1741608, -0.1682285),
	vec2(-0.09369049, 0.3196758),
	vec2(0.185363, 0.3213367),
	vec2(-0.1493771, -0.3147511),
	vec2(0.4452095, 0.2580113),
	vec2(-0.1080467, -0.5329178),
	vec2(0.1604507, 0.5460774),
	vec2(-0.4037193, -0.2611179),
	vec2(0.5947998, -0.2146744),
	vec2(0.3276062, 0.9244621),
	vec2(-0.6518704, -0.2503952),
	vec2(-0.3580975, 0.2806469),
	vec2(0.8587891, 0.4838005),
	vec2(-0.1596546, -0.8791054),
	vec2(-0.3096867, 0.5588146),
	vec2(-0.5128918, 0.1448544),
	vec2(0.8581337, -0.424046),
	vec2(0.1562584, -0.5610626),
	vec2(-0.7647934, 0.2709858),
	vec2(-0.3090832, 0.9020988),
	vec2(0.3935608, 0.4609676),
	vec2(0.3929337, -0.5010948),
	vec2(-0.8682281, -0.1990303),
	vec2(-0.01973724, 0.6478714),
	vec2(-0.3897587, -0.4665619),
	vec2(-0.7416366, -0.4377831),
	vec2(-0.5523247, 0.4272514),
	vec2(-0.5325066, 0.8410385),
	vec2(0.3085465, -0.7842533),
	vec2(0.8400612, -0.200119),
	vec2(0.6632416, 0.3067062),
	vec2(-0.4462856, -0.04265022),
	vec2(0.06892014, 0.812484),
	vec2(0.5149567, -0.7502338),
	vec2(0.6464897, -0.4666451),
	vec2(-0.159861, 0.1038342),
	vec2(0.6455986, 0.04419327),
	vec2(-0.7445076, 0.5035095),
	vec2(0.9430245, 0.3139912),
	vec2(0.0349884, -0.7968109),
	vec2(-0.9517487, 0.2963554),
	vec2(-0.7304786, -0.01006928),
	vec2(-0.5862702, -0.5531025),
	vec2(0.3029106, 0.09497032),
	vec2(0.09025345, -0.3503742),
	vec2(0.4356628, -0.0710125),
	vec2(0.4112572, 0.7500054),
	vec2(0.3401214, -0.3047142),
	vec2(-0.2192158, -0.6911137),
	vec2(-0.4676369, 0.6570358),
	vec2(0.6295372, 0.5629555),
	vec2(0.1253822, 0.9892166),
	vec2(-0.1154335, 0.8248222),
	vec2(-0.4230408, -0.7129914),
};


layout(std140, set = 1, binding = 4) uniform u_ShadowsData
{
	mat4 u_DirLightViewProjection[SHADOW_CASCADES_COUNT];
	vec4 u_CascadePlanes[SHADOW_CASCADES_COUNT];	// stores only x and y (near and far)
	float u_ShadowMaxDistance;
	float u_MaxDistanceFadeOut;
    float u_CascadeBlendDistance;
	int u_SoftShadows;
};

layout(set = 1, binding = 5) uniform sampler2DArray u_DirShadowMap;
layout(set = 1, binding = 6) uniform sampler2DArrayShadow u_DirShadowMapShadow;

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++    Helper Methods    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float SampleShadowMapDepth(vec2 uv, int cascade)
{
    return texture(u_DirShadowMap, vec3(uv, cascade)).r;
}

float SampleShadowMapCompare(vec3 shadowCoords, int cascade)
{
    return texture(u_DirShadowMapShadow, vec4(shadowCoords.xy, cascade, shadowCoords.z));
}

vec3 GetShadowCoords(vec3 worldPos, int cascade)
{
	 vec4 lightSpacePosition = u_DirLightViewProjection[cascade] * vec4(worldPos, 1.0);
     vec2 uv = 0.5 * lightSpacePosition.xy / lightSpacePosition.w + 0.5;
     return vec3(uv, lightSpacePosition.z);
}

float GetBias(vec3 normal, vec3 lightDir, int cascade)
{
    return max(0.0001 * (1.0 - dot(normal, lightDir)), 0.0001);
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   Cascades    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

int GetShadowCascade(float depthViewSpace)
{
    int cascade = SHADOW_CASCADES_COUNT;
    for(int i = 0; i < SHADOW_CASCADES_COUNT; ++i)
    {
        if(depthViewSpace < u_CascadePlanes[i].y)
        {
            cascade = i;
            break;
        }
    }

    return cascade;
}

float GetShadowMaxDistanceFade(float distanceFromCamera)
{
    float maxDistance = u_ShadowMaxDistance;
    float fadeOut = u_MaxDistanceFadeOut;

    return clamp(smoothstep(0.0, 1.0, (distanceFromCamera - (maxDistance - fadeOut)) / fadeOut), 0.0, 1.0);
}

float GetCascadeScale(int cascade)
{
    float scale = 1.0;
    switch(cascade)
    {
    case 0: scale = 2.0; break;
    case 1: scale = 4.0; break;
    case 2: scale = 5.0; break;
    case 3: scale = 6.0; break;
    }
    
   return 1.0 / scale;
}

int GetCascadeBlockerSamples(int cascade)
{	
	int samples = 0;

	switch(cascade)
	{
	case 0: samples = BLOCKER_SEARCH_SAMPLES / 1; break;
	case 1: samples = BLOCKER_SEARCH_SAMPLES / 2; break;
	case 2: samples = BLOCKER_SEARCH_SAMPLES / 2; break;
	case 3: samples = BLOCKER_SEARCH_SAMPLES / 4; break;
	}

	return max(samples, 16);
}

int GetCascadeFilterSamples(int cascade)
{
	int samples = 0;

	switch(cascade)
	{
	case 0: samples = PCF_SEARCH_SAMPLES / 1; break;
	case 1: samples = PCF_SEARCH_SAMPLES / 2; break;
	case 2: samples = PCF_SEARCH_SAMPLES / 2; break;
	case 3: samples = PCF_SEARCH_SAMPLES / 4; break;
	}

	return max(samples, 16);
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   PCSS    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float PenumbraSize(float zReceiver, float zBlocker)
{
    return (zReceiver - zBlocker) / zBlocker;
}

vec2 FindBlocker(vec2 uv, float depth, int cascade, float searchSize, float scale, int numSamples)
{
	float numBlockers = 0.0;
	float blockerSum = 0.0;

	for(int i = 0; i < numSamples; ++i)
	{
		vec2 offset = PoissonDisk[i] * searchSize * scale;
		float shadowMapDepth = SampleShadowMapDepth(uv + offset, cascade);

		if(shadowMapDepth < depth)
		{
			blockerSum += shadowMapDepth;
			numBlockers += 1.0;
		}
	}

	float avgBlockerDepth = blockerSum / numBlockers;

	return vec2(avgBlockerDepth, numBlockers);
}

float PCF_Filter(vec2 uv, float depth, int cascade, float filterRadiusUV, float scale, int numSamples)
{
	float sum = 0.0;

	for(int i = 0; i < numSamples; ++i)
	{
		vec2 offset = PoissonDisk[i] * filterRadiusUV * scale;
		float value = SampleShadowMapCompare(vec3(uv + offset, depth), cascade);

		sum += value;
	}

	sum /= numSamples;
	return sum;
}

float ShadowPCSS(vec3 shadowCoords, int cascade, float lightSize)
{
    vec2 uv = shadowCoords.xy;
    float depth = shadowCoords.z;
    float scale = GetCascadeScale(cascade);

	int numSamples = GetCascadeBlockerSamples(cascade);

    // STEP 1: blocker search
    float searchSize = lightSize * clamp(depth - 0.02, 0.0, 1.0) / depth;
    vec2 blockerInfo = FindBlocker(uv, depth, cascade, searchSize, scale, numSamples);

    int numBlockers = int(blockerInfo.y);
    float avgBlockerDepth = blockerInfo.x;

    // There are no occluders so early out
    if(numBlockers == 0)
        return 1.0;

	// Do not perform filtering if full shadowed
	if(numBlockers == numSamples)
		return 0.0;

    // STEP 2: penumbra size
    //float penumbra = depth * depth - avgBlockerDepth * avgBlockerDepth;
	float penumbra = depth - avgBlockerDepth;

	//float filterRadiusUV = penumbra * lightSize;
    float filterRadiusUV = clamp(penumbra * lightSize, 0.002, 0.1);

	numSamples = GetCascadeFilterSamples(cascade);

    float shadow = PCF_Filter(uv, depth, cascade, filterRadiusUV, scale, numSamples);
    return shadow;
}


/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   MAIN    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float ShadowHard(vec3 shadowCoords, int cascade)
{
    return SampleShadowMapCompare(shadowCoords, cascade);
}

float Shadow(vec3 shadowCoords, int cascade, float lightSize)
{
	if(bool(u_SoftShadows))
	{
		return 1.0 - ShadowPCSS(shadowCoords, cascade, lightSize);
	}
	
	return 1.0 - ShadowHard(shadowCoords, cascade);
}

float ComputeDirectionalLightShadow(float lightSize, vec3 lightDir, vec3 normal, vec3 worldPos, float distanceFromCamera, mat4 cameraView)
{
    float fadeOut = GetShadowMaxDistanceFade(distanceFromCamera);
    if(fadeOut >= 1.0)
        return 0.0;

    vec4 wposViewSpace = cameraView * vec4(worldPos, 1.0);
    float depthViewSpace = abs(wposViewSpace.z);

    int cascade = GetShadowCascade(depthViewSpace);
    vec3 shadowCoords = GetShadowCoords(worldPos, cascade);

	//float bias = GetBias(normal, lightDir, cascade);
	//shadowCoords.z -= bias;

    if(shadowCoords.z > 1.0) 
		return 0.0;

	float shadow = Shadow(shadowCoords, cascade, lightSize);

#if BLEND_CASCADES == 1

    float near = u_CascadePlanes[cascade].x;
    float far = u_CascadePlanes[cascade].y;

    float alpha = (depthViewSpace - near) / (far - near);

    if(u_CascadeBlendDistance != 0.0 && alpha > 1.0 - u_CascadeBlendDistance && cascade != SHADOW_CASCADES_COUNT - 1)
    {
        // get alpha to 0..1 range over the blend distance
        alpha = (alpha - (1.0 - u_CascadeBlendDistance)) / u_CascadeBlendDistance;

        int nextCascade = cascade + 1;
        shadowCoords = GetShadowCoords(worldPos, nextCascade);

        float shadowNextCascade = Shadow(shadowCoords, nextCascade, lightSize);

        shadow = mix(shadow, shadowNextCascade, clamp(alpha, 0.0, 1.0));
    }

#endif

    return (1.0 - fadeOut) * shadow;
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++    Debug    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

vec3 GetCascadeDebugColor(vec3 worldPos, mat4 cameraView)
{
    vec4 wposViewSpace = cameraView * vec4(worldPos, 1.0);
    float depthViewSpace = abs(wposViewSpace.z);

    int cascade = GetShadowCascade(depthViewSpace);

    const vec3 debugColors[4] = vec3[](
        vec3(1.0, 0.0, 0.0), 
        vec3(0.0, 1.0, 0.0), 
        vec3(0.0, 0.0, 1.0), 
        vec3(1.0, 1.0, 0.0));

    vec3 color = debugColors[cascade];

#if defined(DEBUG_BLEND_CASCADES) && BLEND_CASCADES == 1

    float near = u_CascadePlanes[cascade].x;
    float far = u_CascadePlanes[cascade].y;

    float alpha = (depthViewSpace - near) / (far - near);

    if(alpha > 1.0 - u_CascadeBlendDistance && cascade != SHADOW_CASCADES_COUNT - 1)
    {
        // get alpha to 0..1 range over the blend distance
        alpha = (alpha - (1.0 - u_CascadeBlendDistance)) / u_CascadeBlendDistance;

        vec3 colorNextCascade = debugColors[cascade + 1];

        color = mix(color, colorNextCascade, clamp(alpha, 0.0, 1.0));
    }

#endif

   return color;
}
