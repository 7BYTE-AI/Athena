//////////////////////// Athena Shadows ////////////////////////

#define BLOCKER_SEARCH_SAMPLES 16
#define PCF_FILTER_SAMPLES 16

//#define BLEND_CASCADES

const vec2 PoissonDisk[16] = vec2[](
    vec2( -0.9420162,  -0.39906216 ),
    vec2( 0.94558609,  -0.76890725 ),
    vec2( -0.0941841,  -0.92938870 ),
    vec2( 0.34495938,   0.29387760 ),
    vec2( -0.91588581,  0.45771432 ),
    vec2( -0.81544232, -0.87912464 ),
    vec2( -0.38277543,  0.27676845 ),
    vec2( 0.97484398,   0.75648379 ),
    vec2( 0.44323325,  -0.97511554 ),
    vec2( 0.53742981,  -0.47373420 ),
    vec2( -0.26496911, -0.41893023 ),
    vec2( 0.79197514,   0.19090188 ),
    vec2( -0.24188840,  0.99706507 ),
    vec2( -0.81409955,  0.91437590 ),
    vec2( 0.19984126,   0.78641367 ),
    vec2( 0.14383161,  -0.14100790 ));


struct Cascade
{
	vec2 LightFrustumPlanes;
	float SplitDepth;
	float _Padding;
};

layout(std140, set = 1, binding = 4) uniform u_ShadowsData
{
	mat4 u_DirLightView[SHADOW_CASCADES_COUNT];
	mat4 u_DirLightViewProjection[SHADOW_CASCADES_COUNT];
	Cascade u_Cascades[SHADOW_CASCADES_COUNT];
	float u_ShadowMaxDistance;
	float u_MaxDistanceFadeOut;
    float u_CascadeBlendDistance;
	int u_SoftShadows;
};

layout(set = 1, binding = 8) uniform sampler2DArray u_DirShadowMap;
layout(set = 1, binding = 9) uniform sampler2DArrayShadow u_DirShadowMapShadow;

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++    Helper Methods    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float SampleShadowMapDepth(vec2 uv, int cascade)
{
    return texture(u_DirShadowMap, vec3(uv, cascade)).r;
}

float SampleShadowMapCompare(vec3 shadowCoords, int cascade)
{
    return texture(u_DirShadowMapShadow, vec4(shadowCoords.xy, cascade, shadowCoords.z));
}

vec3 GetShadowCoords(vec3 worldPos, int cascade)
{
	 vec4 lightSpacePosition = u_DirLightViewProjection[cascade] * vec4(worldPos, 1.0);
     vec2 uv = 0.5 * lightSpacePosition.xy / lightSpacePosition.w + 0.5;
     return vec3(uv, lightSpacePosition.z);
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   Cascades    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

int GetShadowCascade(float depthViewSpace)
{
    int cascade = SHADOW_CASCADES_COUNT;
    for(int i = 0; i < SHADOW_CASCADES_COUNT; ++i)
    {
        if(depthViewSpace < u_Cascades[i].SplitDepth)
        {
            cascade = i;
            break;
        }
    }

    return cascade;
}

float GetShadowMaxDistanceFade(float distanceFromCamera)
{
    float maxDistance = u_ShadowMaxDistance;
    float fadeOut = u_MaxDistanceFadeOut;

    return clamp(smoothstep(0.0, 1.0, (distanceFromCamera - (maxDistance - fadeOut)) / fadeOut), 0.0, 1.0);
}

float GetBias(vec3 normal, vec3 lightDir, int cascade)
{
	float bias = max(0.0001 * (1.0 - dot(normal, lightDir)), 0.0001);

    float scale = 1.0;
    switch(cascade)
    {
    case 0: scale = 1.0;
    case 1: scale = 2.0;
    case 2: scale = 4.0;
    case 3: scale = 8.0;
    }
    
    bias *= scale / 2.0;

    return bias;
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   PCSS    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float PenumbraSize(float zReceiver, float zBlocker)
{
    return (zReceiver - zBlocker) / zBlocker;
}

vec2 FindBlocker(vec2 uv, float depth, int cascade, float searchSize)
{
	float numBlockers = 0.0;
	float blockerSum = 0.0;

	for(int i = 0; i < BLOCKER_SEARCH_SAMPLES; ++i)
	{
		vec2 offset = PoissonDisk[i] * searchSize;

		float shadowMapDepth = SampleShadowMapDepth(uv + offset, cascade);

		if(shadowMapDepth < depth)
		{
			blockerSum += shadowMapDepth;
			numBlockers += 1.0;
		}
	}

	float avgBlockerDepth = blockerSum / numBlockers;

	return vec2(avgBlockerDepth, numBlockers);
}

float PCF_Filter(vec2 uv, float depth, int cascade, float filterRadiusUV)
{
	float sum = 0.0;

	for(int i = 0; i < PCF_FILTER_SAMPLES; ++i)
	{
		vec2 offset = PoissonDisk[i] * filterRadiusUV;
		float value = SampleShadowMapCompare(vec3(uv + offset, depth), cascade);

		sum += value;
	}

	sum /= PCF_FILTER_SAMPLES;
	return sum;
}

float ShadowPCSS(vec3 shadowCoords, int cascade, float lightSize, vec3 worldPos)
{
    vec4 viewPos = u_DirLightView[cascade] * vec4(worldPos, 1.0);
    float zReceiver = -viewPos.z / viewPos.w;

    float lightNearPlane = u_Cascades[cascade].LightFrustumPlanes.x;
    float lightFarPlane = u_Cascades[cascade].LightFrustumPlanes.y;

    // STEP 1: blocker search 
    float searchWidth = lightSize * (zReceiver - lightNearPlane) / zReceiver;
    vec2 blockerInfo = FindBlocker(shadowCoords.xy, shadowCoords.z, cascade, searchWidth);

	int numBlockers = int(blockerInfo.y);

    numBlockers -= 1;
    if(numBlockers < 1)
        return 1.0;

    // Convert to view space
	float avgBlockerDepth = blockerInfo.x;
    avgBlockerDepth = lightFarPlane * lightNearPlane / (lightFarPlane - avgBlockerDepth * (lightFarPlane - lightNearPlane));

    // STEP 2: penumbra size
    float penumbraRatio = PenumbraSize(zReceiver, avgBlockerDepth);
    float filterRadiusUV =  penumbraRatio * lightSize * lightNearPlane / zReceiver;

    // STEP 3: filtering 
    return PCF_Filter(shadowCoords.xy, shadowCoords.z, cascade, filterRadiusUV);
}


/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   MAIN    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float ShadowHard(vec3 shadowCoords, int cascade)
{
    return SampleShadowMapCompare(shadowCoords, cascade);
}

float Shadow(vec3 shadowCoords, int cascade, float lightSize, vec3 worldPos)
{
	if(bool(u_SoftShadows))
	{
		return 1.0 - ShadowPCSS(shadowCoords, cascade, lightSize, worldPos);
	}
	
	return 1.0 - ShadowHard(shadowCoords, cascade);
}

float ComputeDirectionalLightShadow(float lightSize, vec3 lightDir, vec3 normal, vec3 worldPos, float distanceFromCamera, mat4 cameraView)
{
    float fadeOut = GetShadowMaxDistanceFade(distanceFromCamera);
    if(fadeOut >= 1.0)
        return 0.0;

    vec4 wposViewSpace = cameraView * vec4(worldPos, 1.0);
    float depthViewSpace = abs(wposViewSpace.z);

    int cascade = GetShadowCascade(depthViewSpace);
    vec3 shadowCoords = GetShadowCoords(worldPos, cascade);

	float bias = GetBias(normal, lightDir, cascade);

	//shadowCoords.z -= bias;

    if(shadowCoords.z > 1.0) 
		return 0.0;

	float shadow = Shadow(shadowCoords, cascade, lightSize, worldPos);

#if defined(BLEND_CASCADES)

    float lightNear = u_Cascades[cascade].LightFrustumPlanes.x;
    float lightFar = u_Cascades[cascade].LightFrustumPlanes.y;

    float alpha = (depthViewSpace - lightNear) / (lightFar - lightNear);

    if(alpha > 1.0 - u_CascadeBlendDistance && cascade != SHADOW_CASCADES_COUNT - 1)
    {
        // get alpha to 0..1 range over the blend distance
        alpha = (alpha - (1.0 - u_CascadeBlendDistance)) / u_CascadeBlendDistance;

        int nextCascade = cascade + 1;
        shadowCoords = GetShadowCoords(worldPos, nextCascade);

        float shadowNextCascade = Shadow(shadowCoords, nextCascade, lightSize, worldPos);

        shadow = mix(shadow, shadowNextCascade, clamp(alpha, 0.0, 1.0));
    }

#endif

    return (1.0 - fadeOut) * shadow;
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++    Debug    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

vec3 GetCascadeDebugColor(vec3 worldPos, mat4 cameraView)
{
    vec4 wposViewSpace = cameraView * vec4(worldPos, 1.0);
    float depthViewSpace = abs(wposViewSpace.z);

    int cascade = GetShadowCascade(depthViewSpace);

    const vec3 debugColors[4] = vec3[](
        vec3(1.0, 0.0, 0.0), 
        vec3(0.0, 1.0, 0.0), 
        vec3(0.0, 0.0, 1.0), 
        vec3(1.0, 1.0, 0.0));

    vec3 color = debugColors[cascade];

#if defined(BLEND_CASCADES)

    float lightNear = u_Cascades[cascade].LightFrustumPlanes.x;
    float lightFar = u_Cascades[cascade].LightFrustumPlanes.y;

    float alpha = (depthViewSpace - lightNear) / (lightFar - lightNear);

    if(alpha > 1.0 - u_CascadeBlendDistance && cascade != SHADOW_CASCADES_COUNT - 1)
    {
        // get alpha to 0..1 range over the blend distance
        alpha = (alpha - (1.0 - u_CascadeBlendDistance)) / u_CascadeBlendDistance;

        vec3 colorNextCascade = debugColors[cascade + 1];
        color = mix(color, colorNextCascade, clamp(alpha, 0.0, 1.0));
    }
#endif

   return color;
}
