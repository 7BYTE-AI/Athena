//////////////////////// Athena Shadows ////////////////////////

struct Cascade
{
	vec2 LightFrustumPlanes;
	float SplitDepth;
	float _Padding;
};

layout(std140, set = 1, binding = 4) uniform u_ShadowsData
{
	mat4 u_DirLightView[SHADOW_CASCADES_COUNT];
	mat4 u_DirLightViewProjection[SHADOW_CASCADES_COUNT];
	Cascade u_Cascades[SHADOW_CASCADES_COUNT];
	float u_ShadowMaxDistance;
	float u_MaxDistanceFadeOut;
};

layout(set = 1, binding = 8) uniform sampler2DArray u_DirShadowMap;


float GetShadowMaxDistanceFade(float distanceFromCamera)
{
    float fade = 1.0;
    if(distanceFromCamera < u_ShadowMaxDistance)
    {
        fade = clamp(smoothstep(0.0, 1.0, (distanceFromCamera - (u_ShadowMaxDistance - u_MaxDistanceFadeOut)) / u_MaxDistanceFadeOut), 0.0, 1.0);
    }

    return fade;
}

int GetShadowCascade(vec3 worldPos, mat4 cameraView)
{
    vec4 worldPosViewSpace = cameraView * vec4(worldPos, 1.0);
    float depthValue = abs(worldPosViewSpace.z);

    int cascade = SHADOW_CASCADES_COUNT;
    for(int i = 0; i < SHADOW_CASCADES_COUNT; ++i)
    {
        if(depthValue < u_Cascades[i].SplitDepth)
        {
            cascade = i;
            break;
        }
    }

    return cascade;
}

vec3 GetShadowCoords(vec3 worldPos, int cascade)
{
	 vec4 lightSpacePosition = u_DirLightViewProjection[cascade] * vec4(worldPos, 1.0);
     vec2 uv = 0.5 * lightSpacePosition.xy / lightSpacePosition.w + 0.5;
     return vec3(uv, lightSpacePosition.z);
}

float GetBias(vec3 normal, vec3 lightDir)
{
    float bias = max(0.001 * (1.0 - dot(normal, lightDir)), 0.001);
    return bias;
}

float HardShadow(vec3 shadowCoords, int cascade)
{
    float shadowMapDepth = texture(u_DirShadowMap, vec3(shadowCoords.xy, cascade)).r;
    if(shadowMapDepth < shadowCoords.z)
        return 1.0;

    return 0.0;
}

float ComputeDirectionalLightShadow(vec3 lightDir, vec3 normal, vec3 worldPos, float distanceFromCamera, mat4 cameraView)
{
    float fadeOut = GetShadowMaxDistanceFade(distanceFromCamera);
    if(fadeOut >= 1.0)
        return 0.0;

    int cascade = GetShadowCascade(worldPos, cameraView);
    vec3 shadowCoords = GetShadowCoords(worldPos, cascade);
    float bias = GetBias(normal, lightDir);

    if(shadowCoords.z > 1.0) return 0.0;

    float shadow = HardShadow(shadowCoords, cascade);

    return (1.0 - fadeOut) * shadow;
}

vec3 GetCascadeDebugColor(vec3 worldPos, mat4 cameraView)
{
    int cascade = GetShadowCascade(worldPos, cameraView);

    const vec3 debugColors[4] = vec3[](
        vec3(1.0, 0.0, 0.0), 
        vec3(0.0, 1.0, 0.0), 
        vec3(0.0, 0.0, 1.0), 
        vec3(1.0, 1.0, 0.0));

   return debugColors[cascade];
}
