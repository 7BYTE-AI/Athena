//////////////////////// Athena Shadows ////////////////////////

#define BLOCKER_SEARCH_SAMPLES 16
#define PCF_FILTER_SAMPLES 32

//#define ROTATE_SAMPLE


const vec2 PoissonDisk[64] = vec2[](
	vec2(0.0617981, 0.07294159),
	vec2(0.6470215, 0.7474022),
	vec2(-0.5987766, -0.7512833),
	vec2(-0.693034, 0.6913887),
	vec2(0.6987045, -0.6843052),
	vec2(-0.9402866, 0.04474335),
	vec2(0.8934509, 0.07369385),
	vec2(0.1592735, -0.9686295),
	vec2(-0.05664673, 0.995282),
	vec2(-0.1203411, -0.1301079),
	vec2(0.1741608, -0.1682285),
	vec2(-0.09369049, 0.3196758),
	vec2(0.185363, 0.3213367),
	vec2(-0.1493771, -0.3147511),
	vec2(0.4452095, 0.2580113),
	vec2(-0.1080467, -0.5329178),
	vec2(0.1604507, 0.5460774),
	vec2(-0.4037193, -0.2611179),
	vec2(0.5947998, -0.2146744),
	vec2(0.3276062, 0.9244621),
	vec2(-0.6518704, -0.2503952),
	vec2(-0.3580975, 0.2806469),
	vec2(0.8587891, 0.4838005),
	vec2(-0.1596546, -0.8791054),
	vec2(-0.3096867, 0.5588146),
	vec2(-0.5128918, 0.1448544),
	vec2(0.8581337, -0.424046),
	vec2(0.1562584, -0.5610626),
	vec2(-0.7647934, 0.2709858),
	vec2(-0.3090832, 0.9020988),
	vec2(0.3935608, 0.4609676),
	vec2(0.3929337, -0.5010948),
	vec2(-0.8682281, -0.1990303),
	vec2(-0.01973724, 0.6478714),
	vec2(-0.3897587, -0.4665619),
	vec2(-0.7416366, -0.4377831),
	vec2(-0.5523247, 0.4272514),
	vec2(-0.5325066, 0.8410385),
	vec2(0.3085465, -0.7842533),
	vec2(0.8400612, -0.200119),
	vec2(0.6632416, 0.3067062),
	vec2(-0.4462856, -0.04265022),
	vec2(0.06892014, 0.812484),
	vec2(0.5149567, -0.7502338),
	vec2(0.6464897, -0.4666451),
	vec2(-0.159861, 0.1038342),
	vec2(0.6455986, 0.04419327),
	vec2(-0.7445076, 0.5035095),
	vec2(0.9430245, 0.3139912),
	vec2(0.0349884, -0.7968109),
	vec2(-0.9517487, 0.2963554),
	vec2(-0.7304786, -0.01006928),
	vec2(-0.5862702, -0.5531025),
	vec2(0.3029106, 0.09497032),
	vec2(0.09025345, -0.3503742),
	vec2(0.4356628, -0.0710125),
	vec2(0.4112572, 0.7500054),
	vec2(0.3401214, -0.3047142),
	vec2(-0.2192158, -0.6911137),
	vec2(-0.4676369, 0.6570358),
	vec2(0.6295372, 0.5629555),
	vec2(0.1253822, 0.9892166),
	vec2(-0.1154335, 0.8248222),
	vec2(-0.4230408, -0.7129914));


struct Cascade
{
	vec2 LightFrustumPlanes;
	float SplitDepth;
	float _Padding;
};

layout(std140, set = 1, binding = 4) uniform u_ShadowsData
{
	mat4 u_DirLightView[SHADOW_CASCADES_COUNT];
	mat4 u_DirLightViewProjection[SHADOW_CASCADES_COUNT];
	Cascade u_Cascades[SHADOW_CASCADES_COUNT];
	float u_ShadowMaxDistance;
	float u_MaxDistanceFadeOut;
	float u_LightSize;
	int u_SoftShadows;
};

layout(set = 1, binding = 8) uniform sampler2DArray u_DirShadowMap;


/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++    Helper Methods    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float SampleShadowMapDepth(vec2 uv, int cascade)
{
    return texture(u_DirShadowMap, vec3(uv, cascade)).r;
}

float SampleShadowMapCompare(vec3 shadowCoords, int cascade)
{
    float shadowMapDepth = SampleShadowMapDepth(shadowCoords.xy, cascade);
    if(shadowMapDepth < shadowCoords.z)
        return 0.0;

    return 1.0;
}

vec3 GetShadowCoords(vec3 worldPos, int cascade)
{
	 vec4 lightSpacePosition = u_DirLightViewProjection[cascade] * vec4(worldPos, 1.0);
     vec2 uv = 0.5 * lightSpacePosition.xy / lightSpacePosition.w + 0.5;
     return vec3(uv, lightSpacePosition.z);
}

float ValueNoise(vec3 pos)
{
	vec3 Noise_skew = pos + 0.2127 + pos.x * pos.y * pos.z * 0.3713;
	vec3 Noise_rnd = 4.789 * sin(489.123 * (Noise_skew));
	return fract(Noise_rnd.x * Noise_rnd.y * Noise_rnd.z * (1.0 + Noise_skew.x));
}

vec2 Rotate(vec2 pos, vec2 rotationTrig)
{
	return vec2(pos.x * rotationTrig.x - pos.y * rotationTrig.y, pos.y * rotationTrig.x + pos.x * rotationTrig.y);
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   Cascades    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float GetCascadeScale(int cascade)
{
    switch(cascade)
    {
    case 0: return 1.0;
    case 1: return 1.0 / 1.0;
    case 2: return 1.0 / 1.0;
    case 3: return 1.0 / 1.0;
    }

    return 1.0;
}

int GetShadowCascade(vec3 worldPos, mat4 cameraView)
{
    vec4 worldPosViewSpace = cameraView * vec4(worldPos, 1.0);
    float depthValue = abs(worldPosViewSpace.z);

    int cascade = SHADOW_CASCADES_COUNT;
    for(int i = 0; i < SHADOW_CASCADES_COUNT; ++i)
    {
        if(depthValue < u_Cascades[i].SplitDepth)
        {
            cascade = i;
            break;
        }
    }

    return cascade;
}

float GetShadowMaxDistanceFade(float distanceFromCamera)
{
    float fade = 1.0;
    if(distanceFromCamera < u_ShadowMaxDistance)
    {
        fade = clamp(smoothstep(0.0, 1.0, (distanceFromCamera - (u_ShadowMaxDistance - u_MaxDistanceFadeOut)) / u_MaxDistanceFadeOut), 0.0, 1.0);
    }

    return fade;
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   PCSS    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

vec2 FindBlocker(vec2 uv, float depth, int cascade, float scale, float searchSize, vec2 rotationTrig)
{
	float numBlockers = 0.0;
	float blockerSum = 0.0;

	for(int i = 0; i < BLOCKER_SEARCH_SAMPLES; ++i)
	{
		vec2 offset = PoissonDisk[i] * searchSize * scale;

#if defined(ROTATE_SAMPLE)
		offset = Rotate(offset, rotationTrig);
#endif

		float shadowMapDepth = SampleShadowMapDepth(uv + offset, cascade);

		if(shadowMapDepth < depth)
		{
			blockerSum += shadowMapDepth;
			numBlockers += 1.0;
		}
	}

	float avgBlockerDepth = blockerSum / numBlockers;

	return vec2(avgBlockerDepth, numBlockers);
}

float PCF_Filter(vec2 uv, float depth, int cascade , float scale, float filterRadiusUV, float penumbra, vec2 rotationTrig)
{
	float sum = 0.0;

	for(int i = 0; i < PCF_FILTER_SAMPLES; ++i)
	{
		vec2 offset = PoissonDisk[i] * filterRadiusUV * scale;

#if defined(ROTATE_SAMPLE)
		offset = Rotate(offset, rotationTrig);
#endif

		float value = SampleShadowMapCompare(vec3(uv + offset, depth), cascade);

		sum += value;
	}

	sum /= PCF_FILTER_SAMPLES;
	return sum;
}

float ShadowPCSS(vec3 shadowCoords, int cascade, float random)
{
	vec2 uv = shadowCoords.xy;
	float depth = shadowCoords.z;
	float scale = GetCascadeScale(cascade);

	float rotationAngle = random * 3.1415926;
	vec2 rotationTrig = vec2(cos(rotationAngle), sin(rotationAngle));

    float lightNearPlane = u_Cascades[cascade].LightFrustumPlanes.x;
    float lightFarPlane = u_Cascades[cascade].LightFrustumPlanes.y;

	// STEP 1: blocker search
	float searchSize = u_LightSize * clamp(depth - 0.02, 0, 1) / depth;
	vec2 blockerInfo = FindBlocker(uv, depth, cascade, scale, searchSize, rotationTrig);

	if (blockerInfo.y < 1.0)
	{
		//There are no occluders so early out (this saves filtering)
		return 1.0;
	}

	// STEP 2: penumbra size
	float penumbra = (depth - blockerInfo.x);

	float filterRadiusUV = penumbra * u_LightSize;
	filterRadiusUV *= filterRadiusUV;

	// STEP 3: PCF filter
	float shadow = PCF_Filter(uv, depth, cascade, scale, filterRadiusUV, penumbra, rotationTrig);

	return shadow;
}


/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++   MAIN    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

float ShadowHard(vec3 shadowCoords, int cascade)
{
    return SampleShadowMapCompare(shadowCoords, cascade);
}

float ComputeDirectionalLightShadow(vec3 lightDir, vec3 normal, vec3 worldPos, float distanceFromCamera, mat4 cameraView)
{
    float fadeOut = GetShadowMaxDistanceFade(distanceFromCamera);
    if(fadeOut >= 1.0)
        return 0.0;

    int cascade = GetShadowCascade(worldPos, cameraView);
    vec3 shadowCoords = GetShadowCoords(worldPos, cascade);

    if(shadowCoords.z > 1.0) return 0.0;

	float random = ValueNoise(worldPos);

	float shadow = bool(u_SoftShadows) ? ShadowPCSS(shadowCoords, cascade, random) : ShadowHard(shadowCoords, cascade);

    return (1.0 - fadeOut) * (1 - shadow);
}

/*
=========================================================================================================================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++    Debug    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=========================================================================================================================================
*/

vec3 GetCascadeDebugColor(vec3 worldPos, mat4 cameraView)
{
    int cascade = GetShadowCascade(worldPos, cameraView);

    const vec3 debugColors[4] = vec3[](
        vec3(1.0, 0.0, 0.0), 
        vec3(0.0, 1.0, 0.0), 
        vec3(0.0, 0.0, 1.0), 
        vec3(1.0, 1.0, 0.0));

   return debugColors[cascade];
}

float FindBlockerDebug(vec3 worldPos, mat4 cameraView)
{
	int cascade = GetShadowCascade(worldPos, cameraView);
    vec3 shadowCoords = GetShadowCoords(worldPos, cascade);

	vec2 uv = shadowCoords.xy;
	float depth = shadowCoords.z;
	float scale = GetCascadeScale(cascade);

	float searchSize = u_LightSize * (depth - 0.02) / depth;
	vec2 blockerInfo = FindBlocker(uv, depth, cascade, scale, searchSize, vec2(0, 0));

	return blockerInfo.x;
}

float PenumbraDebug(vec3 worldPos, mat4 cameraView)
{
	int cascade = GetShadowCascade(worldPos, cameraView);
    vec3 shadowCoords = GetShadowCoords(worldPos, cascade);

	vec2 uv = shadowCoords.xy;
	float depth = shadowCoords.z;
	float scale = GetCascadeScale(cascade);

	float searchSize = u_LightSize * (depth - 0.02) / depth;
	vec2 blockerInfo = FindBlocker(uv, depth, cascade, scale, searchSize, vec2(0, 0));

	return depth - blockerInfo.x;
}

